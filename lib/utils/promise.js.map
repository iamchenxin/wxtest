{"version":3,"sources":["utils/promise.js"],"names":["wait","promisify1arg","promisify","promisifyObject","queue","mustBe","delay","Promise","resolve","setTimeout","callback_fn","to_promise","args","reject","push","err","result","length","apply","fn","firstData","res","obj","promisedObj","key","arr","promiseProducer","concurrency","Infinity","Math","min","slice","results","total","i","next","item","shift","promise","then"],"mappings":"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","file":"promise.js","sourcesContent":["/* @flow */\nimport { pro } from 'flow-dynamic';\nconst { mustBe } = pro;\n\nexport function wait(delay: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, delay);\n  });\n}\n\n// result alway be an Array [a,b,c]\nexport function promisify1arg(callback_fn: Function): () => Promise<any> {\n  return to_promise;\n\n  function to_promise(...args): Promise<any>  {\n    return new Promise(function(resolve, reject) {\n      args.push(function(err, ...result) { // all nodejs's last arg is callback\n        mustBe(true, result.length <= 1,\n          'This function must return signle result');\n        if (err) {\n          reject(err);\n        } else {\n          resolve(result[0]);\n        }\n      });\n      callback_fn.apply(null, args);\n    });\n  }\n}\nexport function promisify(fn: Function, firstData?: boolean): () => Promise<any> {\n  return function(...args): Promise<any> {\n    return new Promise(function(resolve, reject) {\n      args.push(function(err, ...result) {\n        let res = result;\n\n        if (firstData) {\n          res = err;\n          err = null;\n        }\n\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      });\n\n      fn.apply(null, args);\n    });\n  };\n}\n\nexport function promisifyObject(obj: {\n  [key: string]: Function\n}): {\n  [key: string]: () => Promise<any>\n} {\n  const promisedObj = {};\n  for (const key in obj) {\n    promisedObj[key] = promisify(obj[key]);\n  }\n  return promisedObj;\n}\n\nexport function queue<T>(\n  arr: Array<any>,\n  promiseProducer: (result: any) => Promise<T>,\n  concurrency: number = Infinity,\n): Promise<Array<T>> {\n  concurrency = Math.min(concurrency, arr.length);\n\n  // clone\n  arr = arr.slice();\n\n  const results = [];\n  let total = arr.length;\n  if (!total) {\n    return Promise.resolve(results);\n  }\n\n  return new Promise((resolve, reject) => {\n    for (let i = 0; i < concurrency; i++) {\n      next();\n    }\n\n    function next() {\n      const item = arr.shift();\n      const promise = promiseProducer(item);\n\n      promise.then(function(result) {\n        results.push(result);\n\n        total--;\n        if (total === 0) {\n          resolve(results);\n        } else {\n          if (arr.length) {\n            next();\n          }\n        }\n      }, reject);\n    }\n  });\n}\n"],"sourceRoot":"/home/iamchenxin/project/workout/wxtest/src"}